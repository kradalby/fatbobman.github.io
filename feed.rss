<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swift笔记本</title><description>徐杨的个人博客</description><link>http://www.fatbobman.com</link><language>zh</language><lastBuildDate>Sat, 23 Jan 2021 11:37:37 +0800</lastBuildDate><pubDate>Sat, 23 Jan 2021 11:37:37 +0800</pubDate><ttl>250</ttl><atom:link href="http://www.fatbobman.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">http://www.fatbobman.com/posts/first-post</guid><title>abcdefg</title><description>A description of my first post.</description><link>http://www.fatbobman.com/posts/first-post</link><pubDate>Wed, 20 Jan 2021 13:04:00 +0800</pubDate><content:encoded><![CDATA[<p>My first post's text.</p><p align="center">
    <img src="Logo.png" width="278" max-width="90%" alt=“Ink” />
</p><p align="center">
    <img src="https://img.shields.io/badge/Swift-5.2-orange.svg" />
    <a href="https://swift.org/package-manager">
        <img src="https://img.shields.io/badge/swiftpm-compatible-brightgreen.svg?style=flat" alt="Swift Package Manager" />
    </a>
     <img src="https://img.shields.io/badge/platforms-mac+linux-brightgreen.svg?style=flat" alt="Mac + Linux" />
    <a href="https://twitter.com/johnsundell">
        <img src="https://img.shields.io/badge/twitter-@johnsundell-blue.svg?style=flat" alt="Twitter: @johnsundell" />
    </a>
</p><table><tbody><tr><td><img src="https://img.shields.io/badge/Swift-5.2-orange.svg" /></td><td><img src="https://img.shields.io/badge/Swift-5.2-orange.svg" /></td><td><img src="https://img.shields.io/badge/platforms-mac+linux-brightgreen.svg?style=flat" alt="Mac + Linux" /></td><td><img src="https://img.shields.io/badge/Swift-5.2-orange.svg" /></td></tr></tbody></table><blockquote><p>hello world</p></blockquote><table><thead><tr><th>Header</th><th>Header 2</th></tr></thead><tbody><tr><td>Row 1</td><td>Cell 1</td></tr><tr><td>Row 2</td><td>Cell 2</td></tr></tbody></table><p>Welcome to <strong>Ink</strong>, a fast and flexible Markdown parser written in Swift. It can be used to convert Markdown-formatted strings into HTML, and also supports metadata parsing, as well as powerful customization options for fine-grained post-processing. It was built with a focus on Swift-based web development and other HTML-centered workflows.</p><p>Ink is used to render all articles on <a href="https://swiftbysundell.com">swiftbysundell.com</a>.</p><h2>Converting Markdown into HTML</h2><p>To get started with Ink, all you have to do is to import it, and use its <code>MarkdownParser</code> type to convert any Markdown string into efficiently rendered HTML:</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> Ink

<span class="hljs-keyword">let</span> markdown: <span class="hljs-type">String</span> = ...
<span class="hljs-keyword">let</span> parser = <span class="hljs-type">MarkdownParser</span>()
<span class="hljs-keyword">let</span> html = parser.html(from: markdown)
</code></pre><p>That’s it! The resulting HTML can then be displayed as-is, or embedded into some other context — and if that’s all you need Ink for, then no more code is required.</p><h2>Automatic metadata parsing</h2><p>Ink also comes with metadata support built-in, meaning that you can define key/value pairs at the top of any Markdown document, which will then be automatically parsed into a Swift dictionary.</p><p>To take advantage of that feature, call the <code>parse</code> method on <code>MarkdownParser</code>, which gives you a <code>Markdown</code> value that both contains any metadata found within the parsed Markdown string, as well as its HTML representation:</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> markdown: <span class="hljs-type">String</span> = ...
<span class="hljs-keyword">let</span> parser = <span class="hljs-type">MarkdownParser</span>()
<span class="hljs-keyword">let</span> result = parser.parse(markdown)

<span class="hljs-keyword">let</span> dateString = result.metadata[<span class="hljs-string">"date"</span>]
<span class="hljs-keyword">let</span> html = result.html
</code></pre><p>To define metadata values within a Markdown document, use the following syntax:</p><pre data-language="undefined"><code>
---
keyA: valueA
keyB: valueB
---

Markdown text...
</code></pre><p>The above format is also supported by many different Markdown editors and other tools, even though it’s not part of the <a href="https://daringfireball.net/projects/markdown">original Markdown spec</a>.</p><h2>Powerful customization</h2><p>Besides its <a href="#markdown-syntax-supported">built-in parsing rules</a>, which aims to cover the most common features found in the various flavors of Markdown, you can also customize how Ink performs its parsing through the use of <em>modifiers</em>.</p><p>A modifier is defined using the <code>Modifier</code> type, and is associated with a given <code>Target</code>, which determines the kind of Markdown fragments that it will be used for. For example, here’s how an H3 tag could be added before each code block:</p><pre data-language="swift"><code><span class="hljs-keyword">var</span> parser = <span class="hljs-type">MarkdownParser</span>()

<span class="hljs-keyword">let</span> modifier = <span class="hljs-type">Modifier</span>(target: .codeBlocks) { html, markdown <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;h3&gt;This is a code block:&lt;/h3&gt;"</span> + html
}

parser.addModifier(modifier)

<span class="hljs-keyword">let</span> markdown: <span class="hljs-type">String</span> = ...
<span class="hljs-keyword">let</span> html = parser.html(from: markdown)
</code></pre><p>Modifiers are passed both the HTML that Ink generated for the given fragment, and its raw Markdown representation as well — both of which can be used to determine how each fragment should be customized.</p><h2>Performance built-in</h2><p>Ink was designed to be as fast and efficient as possible, to enable hundreds of full-length Markdown articles to be parsed in a matter of seconds, while still offering a fully customizable API as well. Two key characteristics make this possible:</p><ol><li>Ink aims to get as close to <code>O(N)</code> complexity as possible, by minimizing the amount of times it needs to read the Markdown strings that are passed to it, and by optimizing its HTML rendering to be completely linear. While <em>true</em> <code>O(N)</code> complexity is impossible to achieve when it comes to Markdown parsing, because of its very flexible syntax, the goal is to come as close to that target as possible.<ul><li>hello</li><li>good</li></ul></li></ol><ol start="2"><li>A high degree of memory efficiency is achieved thanks to Swift’s powerful <code>String</code> API, which Ink makes full use of — by using string indexes, ranges and substrings, rather than performing unnecessary string copying between its various operations.</li></ol><h2>System requirements</h2><p>To be able to successfully use Ink, make sure that your system has Swift version 5.2 (or later) installed. If you’re using a Mac, also make sure that <code>xcode-select</code> is pointed at an Xcode installation that includes the required version of Swift, and that you’re running macOS Catalina (10.15) or later.</p><p>Please note that Ink <strong>does not</strong> officially support any form of beta software, including beta versions of Xcode and macOS, or unreleased versions of Swift.</p><h2>Installation</h2><p>Ink is distributed using the <a href="https://swift.org/package-manager">Swift Package Manager</a>. To install it into a project, simply add it as a dependency within your <code>Package.swift</code> manifest:</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> package = <span class="hljs-type">Package</span>(
    ...
    dependencies: [
        .package(url: <span class="hljs-string">"https://github.com/johnsundell/ink.git"</span>, from: <span class="hljs-string">"0.1.0"</span>)
    ],
    ...
)
</code></pre><p>Then import Ink wherever you’d like to use it:</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> Ink
</code></pre><p>For more information on how to use the Swift Package Manager, check out <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager">this article</a>, or <a href="https://github.com/apple/swift-package-manager/tree/master/Documentation">its official documentation</a>.</p><h2>Command line tool</h2><p>Ink also ships with a simple but useful command line tool that lets you convert Markdown to HTML directly from the command line.</p><p>To install it, clone the project and run <code>make</code>:</p><pre data-language="bash"><code>$ git <span class="hljs-built_in">clone</span> https://github.com/johnsundell/Ink.git
$ <span class="hljs-built_in">cd</span> Ink
$ make
</code></pre><p>The command line tool will be installed as <code>ink</code>, and can be passed Markdown text for conversion into HTML in several ways.</p><p>Calling it without arguments will start reading from <code>stdin</code> until terminated with <code>Ctrl+D</code>:</p><pre data-language="undefined"><code>
$ ink
</code></pre><p>Markdown text can be piped in when <code>ink</code> is called without arguments:</p><pre data-language="undefined"><code>
$ echo "*Hello World*" | ink
</code></pre><p>A single argument is treated as a filename, and the corresponding file will be parsed:</p><pre data-language="undefined"><code>
$ ink file.md
</code></pre><p>A Markdown string can be passed directly using the <code>-m</code> or <code>--markdown</code> flag:</p><pre data-language="swift"><code>$ ink -m <span class="hljs-string">"*Hello World*"</span>
</code></pre><p>You can of course also build your own command line tools that utilizes Ink in more advanced ways by importing it as a package.</p><h2>Markdown syntax supported</h2><p>Ink supports the following Markdown features:</p><ul><li>Headings (H1 - H6), using leading pound signs, for example <code>## H2</code>.<ol><li>hello sadlgj; asdg;lkj asd;glkjas d;gl asdg;lk asdglkj asdglkj asdg;lkj asdglkj asdgl;kj asdg;lkj asdg ;ljk asg asdglk <code>sd</code> sdfsalk</li><li>ed</li></ol></li><li>Italic text, by surrounding a piece of text with either an asterisk (<code>*</code>), or an underscore (<code>_</code>). For example <code>*Italic text*</code>.</li><li>Bold text, by surrounding a piece of text with either two asterisks (<code>**</code>), or two underscores (<code>__</code>). For example <code>**Bold text**</code>.</li><li>Text strikethrough, by surrounding a piece of text with two tildes (<code>~~</code>), for example <code>~~Strikethrough text~~</code>.</li><li>Inline code, marked with a backtick on either site of the code.</li><li>Code blocks, marked with three or more backticks both above and below the block.</li><li>Links, using the following syntax: <code>[Title](url)</code>.</li><li>Images, using the following syntax: <code>![Alt text](image-url)</code>.</li><li>Both images and links can also use reference URLs, which can be defined anywhere in a Markdown document using this syntax: <code>[referenceName]: url</code>.</li><li>Both ordered lists (using numbers followed by a period (<code>.</code>) or right parenthesis (<code>)</code>) as bullets) and unordered lists (using either a dash (<code>-</code>), plus (<code>+</code>), or asterisk (<code>*</code>) as bullets) are supported.</li><li>Ordered lists start from the index of the first entry</li><li>Nested lists are supported as well, by indenting any part of a list that should be nested within its parent.</li><li>Horizontal lines can be placed using either three asterisks (<code>***</code>) or three dashes (<code>---</code>) on a new line.</li><li>HTML can be inlined both at the root level, and within text paragraphs.</li><li>Blockquotes can be created by placing a greater-than arrow at the start of a line, like this: <code>&gt; This is a blockquote</code>.</li><li>Tables can be created using the following syntax (the line consisting of dashes (<code>-</code>) can be omitted to create a table without a header row):</li></ul><pre data-language="undefined"><code>
| Header | Header 2 |
| ------ | -------- |
| Row 1  | Cell 1   |
| Row 2  | Cell 2   |

</code></pre><p>Please note that, being a very young implementation, Ink does not fully support all Markdown specs, such as <a href="https://commonmark.org">CommonMark</a>. Ink definitely aims to cover as much ground as possible, and to include support for the most commonly used Markdown features, but if complete CommonMark compatibility is what you’re looking for — then you might want to check out tools like <a href="https://github.com/commonmark/cmark">CMark</a>.</p><h2>Internal architecture</h2><p>Ink uses a highly modular <a href="https://www.swiftbysundell.com/articles/rule-based-logic-in-swift">rule-based</a> internal architecture, to enable new rules and formatting options to be added without impacting the system as a whole.</p><p>Each Markdown fragment is individually parsed and rendered by a type conforming to the internal <code>Readable</code> and <code>HTMLConvertible</code> protocols — such as <code>FormattedText</code>, <code>List</code>, and <code>Image</code>.</p><p>To parse a part of a Markdown document, each fragment type uses a <code>Reader</code> instance to read the Markdown string, and to make assertions about its structure. Errors are <a href="https://www.swiftbysundell.com/articles/using-errors-as-control-flow-in-swift">used as control flow</a> to signal whether a parsing operation was successful or not, which in turn enables the parent context to decide whether to advance the current <code>Reader</code> instance, or whether to rewind it.</p><p>A good place to start exploring Ink’s implementation is to look at the main <code>MarkdownParser</code> type’s <code>parse</code> method, and to then dive deeper into the various <code>Fragment</code> implementations, and the <code>Reader</code> type.</p><h2>Credits</h2><p>Ink was originally written by <a href="https://twitter.com/johnsundell">John Sundell</a> as part of the Publish suite of static site generation tools, which is used to build and generate <a href="https://swiftbysundell.com">Swift by Sundell</a>. The other tools that make up the Publish suite will also be open sourced soon.</p><p>The Markdown format was created by <a href="https://twitter.com/gruber">John Gruber</a>. You can find <a href="https://daringfireball.net/projects/markdown">more information about it here</a>.</p><h2>Contributions and support</h2><p>Ink is developed completely in the open, and your contributions are more than welcome.</p><p>Before you start using Ink in any of your projects, it’s highly recommended that you spend a few minutes familiarizing yourself with its documentation and internal implementation, so that you’ll be ready to tackle any issues or edge cases that you might encounter.</p><p>Since this is a very young project, it’s likely to have many limitations and missing features, which is something that can really only be discovered and addressed as more people start using it. While Ink is used in production to render all of <a href="https://swiftbysundell.com">Swift by Sundell</a>, it’s recommended that you first try it out for your specific use case, to make sure it supports the features that you need.</p><p>This project does not come with GitHub Issues-based support, and users are instead encouraged to become active participants in its continued development — by fixing any bugs that they encounter, or by improving the documentation wherever it’s found to be lacking.</p><p>If you wish to make a change, <a href="https://github.com/JohnSundell/Ink/pull/new">open a Pull Request</a> — even if it just contains a draft of the changes you’re planning, or a test that reproduces an issue — and we can discuss it further from there.</p><p>Hope you’ll enjoy using <strong>Ink</strong>!</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/about/2021/first-post</guid><title>My first post</title><description>A description of my first post.</description><link>http://www.fatbobman.com/about/2021/first-post</link><pubDate>Wed, 20 Jan 2021 13:04:00 +0800</pubDate><content:encoded><![CDATA[<h1>My first post</h1><p>My first post's text.</p><pre data-language="swift"><code> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"adf"</span>)
}
</code></pre><pre data-language="css"><code><span class="hljs-selector-tag">pre</span> <span class="hljs-selector-tag">code</span> {
    <span class="hljs-attribute">display</span>: block;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1a1a1a</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span> <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#a9bcbc</span>;
    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4em</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.95em</span>;
    <span class="hljs-attribute">overflow-x</span>: auto;
    <span class="hljs-attribute">white-space</span>: pre;
    <span class="hljs-attribute">-webkit-overflow-scrolling</span>: touch;
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/new</guid><title>abcdefg</title><description></description><link>http://www.fatbobman.com/posts/new</link><pubDate>Mon, 24 Aug 2020 16:48:00 +0800</pubDate><content:encoded><![CDATA[<p>在SwiftUI中使用List可以非常方便快速的制作各种列表.List其实就是对UITableView进行的封装(更多List的具体用法请参阅<a href="https://zhuanlan.zhihu.com/p/110749923">List基本用法</a>).</p><p>在List中添加动态内容,我们可以使用两种方式</p><blockquote><p>hello wold在SwiftUI中使用List可以非常方便快速的制作各种列表.List其实就是对UITableView进行的封装(更多List的具体用法请参阅[List基本用法</p></blockquote><pre data-language="swift"><code>  <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
  }
</code></pre><ul><li>在List中使用ForEach</li></ul><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
    }
  }
</code></pre><p>在碰到我最近出现的问题之前,我一直以为上述两种用法除了极个别的区别外,基本没有什么不同. 当时知道的区别:</p><ul><li>使用ForEach可以在同一List中,添加多个动态源,且可添加静态内容</li></ul><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(items,id:\.<span class="hljs-keyword">self</span>){ item <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(item)
    }
    <span class="hljs-type">Text</span>(<span class="hljs-string">"其他内容"</span>)
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(i)"</span>)
    }
  }
</code></pre><ul><li>使用ForEach对于动态内容可以控制版式</li></ul><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Rectangle</span>()
        .listRowInsets(<span class="hljs-type">EdgeInsets</span>()) <span class="hljs-comment">//可以控制边界insets</span>
    }
  }
  
  <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>){ i <span class="hljs-keyword">in</span>
     <span class="hljs-type">Rectangle</span>()
        .listRowInsets(<span class="hljs-type">EdgeInsets</span>()) 
        <span class="hljs-comment">// 不可以控制边界insets.   .listRowInsets(EdgeInsets())在List中只对静态内容有效</span>
  }
</code></pre><p>基于以上的区别,我在大多数的时候均采用ForEach在List中装填列表内容,并且都取得了预想的效果.</p><p>但是在最近我在开发一个类似于iOS邮件app的列表时发生了让我无语的状态——列表卡顿到完全无法忍耐.</p><p>通过下面的视频可以看到让我痛苦的app表现</p><video src="http://cdn.fatbobman.com/10ForEach.mov"></video><p>只有十条记录时的状态.非常丝滑</p><pre data-language="swift"><code> <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10000</span>){ i <span class="hljs-keyword">in</span>
        <span class="hljs-type">Cell</span>(id: i)
          .listRowInsets(<span class="hljs-type">EdgeInsets</span>())
          .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
        }
    }
</code></pre><img src="http://www.fatbobman.com/article/SwiftUIinIpad/ipadiPhone.png" alt="abc"/><p>10000条记录的样子</p><p>在10条记录时一切都很完美,但当记录设置为10000条时,完全卡成了ppt的状态.尤其是View初始化便占有了大量的时间.</p><p>起初我认为可能是我写的滑动菜单的问题,但在自己检查代码后排出了这个选项.为了更好的了解在List中Cell的生命周期状态,写了下面的测试代码.</p><pre data-language="swift"><code>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cell</span>:<span class="hljs-title">View</span></span>{
        <span class="hljs-keyword">let</span> id:<span class="hljs-type">Int</span>
        @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> t = <span class="hljs-type">Test</span>()
        <span class="hljs-keyword">init</span>(id:<span class="hljs-type">Int</span>){
            <span class="hljs-keyword">self</span>.id = id
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"init:\(id)"</span>)
        }
        <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()
                .fill(<span class="hljs-type">Color</span>.blue)
                .overlay(
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
                )
                .onAppear{
                    t.id = id
                }
        }
        
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:<span class="hljs-title">ObservableObject</span></span>{
            <span class="hljs-keyword">var</span> id:<span class="hljs-type">Int</span> = <span class="hljs-number">0</span>{
                <span class="hljs-keyword">didSet</span>{
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"get value \(id)"</span>)
                }
            }
            <span class="hljs-keyword">init</span>(){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"init object"</span>)
            }
            <span class="hljs-keyword">deinit</span> {
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"deinit:\(id)"</span>)
            }
        }
    }
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">ObservableObject</span></span>{
        @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> currentID:<span class="hljs-type">Int</span> = <span class="hljs-number">0</span>
    }
</code></pre><p>执行后,发现了一个奇怪的现象:<strong>在List中,如果用ForEach处理数据源,所有的数据源的View竟然都要在List创建时进行初始化,这完全违背了tableView的本来意图</strong>.</p><p>将上面的代码的数据源切换到List的方式进行测试</p><pre data-language="swift"><code> <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10000</span>){ i <span class="hljs-keyword">in</span>
        <span class="hljs-type">Cell</span>(id: i)
          .listRowInsets(<span class="hljs-type">EdgeInsets</span>())
          .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
    }
</code></pre><video src="http://www.fatbobman.com/Users/yangxu/Documents/%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/List%E4%B8%8EForEach/10000withoutForEach.mov"></video><p>熟悉的丝滑又回来了.</p><p><strong>ForEach要预先处理所有数据,提前准备View.并且初始化后,并不自动释放这些View(即使不可见)!</strong>具体可以使用上面的测试代码通过Debug来分析.</p><p>不流畅的原因已经找到了,不过由于List处理的数据源并不能设置listRowInsets,尤其在iOS14下,苹果非常奇怪的屏蔽了不少通过UITableView来设置List的属性的途径,所以为了既能保证性能,又能保证显示需求,只好通过自己包装UITableView来同时满足上述两个条件.</p><p>好在我一直使用<a href="https://github.com/SwiftUIX/SwiftUIX">SwiftUIX</a>这个第三方库,节省了自己写封装代码的时间.将代码做了进一步调整,当前的问题得以解决.</p><pre data-language="swift"><code> <span class="hljs-type">CocoaList</span>(item){ i <span class="hljs-keyword">in</span>
           <span class="hljs-type">Cell</span>(id: i)
           .frame(height:<span class="hljs-number">100</span>)
           .listRowInsets(<span class="hljs-type">EdgeInsets</span>())
           .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
       }.edgesIgnoringSafeArea(.all)
</code></pre><video src="http://www.fatbobman.com/Users/yangxu/Documents/%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/List%E4%B8%8EForEach/10000MyList.mov"></video><p>通过这次碰到的问题,我知道了可以在什么情况下使用ForEach.通过这篇文章记录下来,希望其他人少走这样的弯路.</p><p><strong>后记:</strong></p><p>我已经向苹果反馈了这个问题,希望他们能够进行调整吧(最近苹果对于开发者的feedback回应还是挺及时的,Xcode12发布后,我提交了5个feedback,已经有4个获得了反馈,3个在最新版得到了解决).</p><h3>遗憾:</h3><p>目前的解决方案使我失去了使用ScrollViewReader的机会.</p>]]></content:encoded></item></channel></rss>